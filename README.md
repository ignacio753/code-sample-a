
This is a sample code I wrote to handle calling some store procedures on the database to return data to display on a table.  The purpose is to show some programming best practices.

First we have a FunctionRecord:Base class that was part of a library (called gems in Ruby).  Given that this piece of code was used by multiple projects handling store procedure calls, having this class allowed to share some common logic (https://github.com/ignacio753/code-sample-a/blob/master/gems/function_record.rb).  This base class handles creating the SQL statements to create the database call.  It expects from its children classes: a function_name attribute (as the name says is the name of the db procedure/function to call), required_query_params (name of params that are required, if a param is empty of null it will raise an exception) and args_from_params (these takes the params coming from the API endpoint and formats them with proper defaults)

For this particular application, we would had several API endpoints dealing with table data calls, which will all had very similar parameters and validations, for this reason I created a class called TableDataBase (https://github.com/ignacio753/code-sample-a/blob/master/models/table_data_base.rb) which overrides the args_from_params and required_query_params methods from the FunctionRecord class.  Furthermore you can see that the args_from_params method calls other methods to fill the array of parameters, these methods have been grouped in logical groups, for example one that handles pagination, other that handles sorting.  This allows for children classes and its store procedures, if they provide this functionality they can call an re-use these methods.

On the TableDataSPP child class (https://github.com/ignacio753/code-sample-a/blob/master/models/table_data_spp.rb), you can see how this process works.  The class inherits from TableDataBase and overrides the args_from_params to only call those methods that it really needs, plus adding any other that are specific to its own class.

As you can tell from the previous example I strive for clean, efficient and testable code. I abide by the DRY and SOLID principles like single responsibility. By writing small functions it allows not only to make sure that each methods is encapsulated and does only one thing, but it also allows to easily implement unit testing for the methods.
